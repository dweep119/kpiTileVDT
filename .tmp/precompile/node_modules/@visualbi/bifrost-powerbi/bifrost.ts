module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
  import IVisualSelectionId = powerbi.visuals.ISelectionId;
  export namespace bifrost {
    export interface Data {
      categorical?: Categorical.Data;
      matrix?: Matrix.Data;
      metadata: Metadata;
    }

    export namespace Categorical {
      export interface Data {
        dimensions: Dimension[];
        measures: Measure[];
        rows?: Row[];
        columns?: Column[];
        objects: Objects;
      }

      export interface Objects {
        dimensions: Object[];
        measures: Object[];
      }


      export interface Object {
        id: string;
        name: string;
        themeColor?: string;
        memberObjects?: any;
        [key: string]: any;
      }

      export interface Row {
        ref: IVisualSelectionId;
        value: (string | number)[];
      }
      export interface Dimension {
        id: string;
        name: string;
        role: any;
        values: any[];
        label: string;
      }

      export interface Measure {
        id: string;
        name: string;
        role: any;
        values: number[];
        label: string;
        groupNames: string[];
        highlight: number[];
        minLocal?: number;
        maxLocal?: number;
        conditionalFormatting: string[];
      }

      export interface Selection {
        dimensions: {
          id: string,
          values: any[]
        }[];
        measureIds: string[];
      }
      export interface SelectionValue {
        dimension: Dimension[];
        measures: Measure[];
        selectionIndexes: number[];
      }
    }

    export interface Metadata {
      dimensions: Column[];
      measures: Column[];
    }


    export interface Column {
      name: string;
      label: string;
      role: any;
      type: ValueTypeDescriptor;
      groupNames?: string[];
      format?: string;
      themeColor?: string;
      object?: any;
    }


    export namespace Matrix {
      export interface Data {
        rows: DataNode[];
        columns: DataNode[];
        valueSources?: DataNode[];
      }
      export interface DataNode {
        id?: string;
        member?: any;
        label?: string;
        role?: any;
        values?: number[];
        ref?: IVisualSelectionId;
        isMeasure?: boolean;
        children?: DataNode[];
        level?: number;
        format?: any;
      }
    }

  }
}

module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        export interface RenderOptions {
            data: Data;
            element: HTMLElement;
            highContrast: HighContrastColors;
            selectionIdBuilder: SelectionIdBuilder;
            updateType: VisualUpdateType;
            settings: VisualSettings;
            viewMode: ViewMode;
            sampleVisual: boolean;
        }

        export interface HighContrastColors {
            isHighContrast: boolean;
            background: string;
            foreground: string;
            foregroundSelected: string;
            hyperlink: string;
        }
        export interface LandingPageConfig {
			title?: string;
			content?: string;
			urlInfo?: string;
            url?: string;
            logoImage?: string;
			html?: HTMLElement;
		}
        export interface InitComponentConfig {
            [key: string]: any;
            useDefaultLandingPage?: boolean;
            editor?: boolean;
            isMeasureComponent?: boolean;
            getSettingsUIConfiguration?(): SettingsSchema.Section[];
            mergeProps?: MergeProp[];
            conditionalFormattingProperty?: {
                sectionId: string;
                propertyId: string;
            };
            resizeHandler?: {
                callBack(): any;
                timeOut?: number
            };
        }
        export interface MergeProp {
            role: string;
            sectionIterator?: {
                section: string;
                property: string;
            },
            dimensionIndex?: number,
            properties?: {
                section: string,
                name: string,
                dimensionSection? : string
            }[]
        }
    }
}

module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        export namespace SettingsSchema {
            export class IteratorType {
                static SERIES = 0;
                static GROUP = 1;
                static DIMENSION = 2;
                static MEASURE = 3;
            }
            export class PropertyType {
                static STATIC = 0;
                static ITERATOR = 1;
            }

            export interface ValidValues {
                numberRange?: {
                    min: number;
                    max: number;
                };
                [key: string]: any;
            }

            export interface Property {
                name: (string | string[]);
                isIteratorVisible? : Function;
                getIteratorText?: Function;
                type?: PropertyType;
                validValues?: ValidValues;
                iteratorType?: IteratorType;
                roles?: string[];
                isVisible?: (boolean | Function); // Default value true,
                defaultValue?: any[];
                dimensionIndex?: number;
            }

            export interface Section {
                name: string;
                isVisible?: (boolean | Function); // Default value true
                properties?: Property[];
                sectionIterator?: {
                    role: string,
                    property: string
                }
            }
        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        export namespace IConditionalFormatting {
            export interface Rule {
                name: string;
                color: string;
                highlighedMeasure: string;
                enabled: boolean;
                conditionalOperator: string;
                conditions: any[];
            }
        
            export interface SingleMeasure {
                ruleType: string;
                comparisionMeasure: string;
                dynamicComparisonValue: Categorical.Selection[];
                comparisonValue: number;
                operator: string;
                valueType: string;
                from?: number;
                dynamicFrom?: Categorical.Selection[];
                to?: number;
                dynamicTo?: Categorical.Selection[];
            }
        
            export interface MeasureCalculation {
                ruleType: string;
                comparisionMeasure: string;
                operator: string;
                calculationType1: string;
                calculationValue1: number;
                calculationMeasure1: string;
                calculationOperator: string;
                calculationType2: string;
                calculationValue2: number;
                calculationMeasure2: string;
            }
        
            export interface Dimension {
                ruleType: string;
                dimension: string;
                aggregationType: string;
                countOperator: string;
                count: number;
                dimensionMembers: {
                    value: string;
                    label: string;
                }[];
            }
            
            export interface TargetRule {
                color: string;
                from: number;
                to: number;
            }
        }
    }
}

module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        export interface ProProperty {
            section: string;
            name: string;
            checkUsage?: Function;
        }
        export interface LicenseStatus {
            isHardStop?: boolean;
            valid: boolean;
            expired?: boolean;
            isNoLicence? : boolean;
        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662.bifrost  {
    export class DataObjectUtils {
        static getMeasureObjects(objects: bifrost.Categorical.Objects, name: string): bifrost.Categorical.Object {
            return objects.measures.filter(measure => measure.name === name)[0];
        }
        static getDimensionObjects(objects: bifrost.Categorical.Objects, name: string): bifrost.Categorical.Object {
            return objects.dimensions.filter(dimension => dimension.name === name)[0];
        }

        static getMeasureObjectsFromId(objects: bifrost.Categorical.Objects, id: string): bifrost.Categorical.Object {
            return objects.measures.filter(measure => measure.id === id)[0];
        }

        static getDimensionObjectsFromId(objects: bifrost.Categorical.Objects, id: string): bifrost.Categorical.Object {
            return objects.dimensions.filter(dimension => dimension.id === id)[0];
        }

        static getMetaData(metadata: bifrost.Metadata, name: string): bifrost.Column {
            let measure = metadata.measures.filter(measure => measure.name === name)[0];
            if (measure) return measure;
            return metadata.dimensions.filter(dimension => dimension.name === name)[0];
        }

        static getMeasureLabelFromName(metadata: bifrost.Metadata, name: string): string {
            const measure = metadata.measures.filter(measure => measure.name === name)[0];
            return measure ? measure.label : null;
        }
        static getDimensionLabelFromName(metadata: bifrost.Metadata, name: string): string {
            const measure = metadata.dimensions.filter(measure => measure.name === name)[0];
            return measure ? measure.label : null;
        }

    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        "use strict";
        let Sentry = (window as any).Sentry;
        export function logExceptions(): MethodDecorator {
            return function (target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<Function>)
                : TypedPropertyDescriptor<Function> {

                return {
                    value: function () {
                        try {
                            return descriptor.value.apply(this, arguments);
                        } catch (e) {
                            console.log(e);
                            if (Sentry) {
                                Sentry.captureException(e);
                            }
                        }
                    }
                }
            }
        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        export namespace data {
            import IVisualHost = powerbi.extensibility.visual.IVisualHost;
            import DataView = powerbi.DataView;
            import DataViewMetadataColumn = powerbi.DataViewMetadataColumn;
            import DataViewValueColumn = powerbi.DataViewValueColumn;
            import DataViewCategoryColumn = powerbi.DataViewCategoryColumn;

            export class DataLayer {
                static formatData({ dataView, host, dataLayerConfig = {}, mergePropsConfig = [], bifrostProperty }: { dataView: DataView, host: IVisualHost, dataLayerConfig?: any, mergePropsConfig?: any, bifrostProperty: any }): bifrost.Data {
                    let categorical: Categorical.Data,
                        matrix: Matrix.Data;
                    if (dataView.categorical) {
                        categorical = DataLayer.getCategoricalData(dataView, host, dataLayerConfig, mergePropsConfig, bifrostProperty);
                    } else if (dataView.matrix) {
                        matrix = DataLayer.getMatrixData(dataView, host);
                    }

                    return {
                        categorical,
                        matrix,
                        metadata: DataLayer.getMetadata(dataView, host)
                    } as bifrost.Data;
                }

                static getMatrixData(dataView: DataView, host: IVisualHost): Matrix.Data {
                    let matrixData = {
                        columns: DataLayer.getDataSourceMatrixColumn(dataView.matrix.columns.root,
                            dataView.matrix.columns.levels,
                            host
                        ).children,
                        rows: DataLayer.getDataSourceMatrixColumn(dataView.matrix.rows.root,
                            dataView.matrix.rows.levels,
                            host).children,
                        valueSources: dataView.matrix.valueSources
                    };
                    return matrixData;
                }

                static getDataSourceMatrixColumn(children: DataViewMatrixNode, levels: DataViewHierarchyLevel[], host: IVisualHost): Matrix.DataNode {
                    let level = children.level || 0;
                    let levelSourceIndex = 0;
                    if (children.levelValues) {
                        levelSourceIndex = children.levelValues[0].levelSourceIndex;
                    } else if (children.levelSourceIndex) {
                        levelSourceIndex = children.levelSourceIndex;
                    }
                    let column: Matrix.DataNode = {};
                    let columnMetaData: DataViewMetadataColumn;
                    if (levels[level]) {
                        columnMetaData = levels[level].sources[levelSourceIndex];
                        column = {
                            "id": columnMetaData.queryName,
                            "role": columnMetaData.roles,
                            "label": columnMetaData.displayName,
                            "member": columnMetaData.isMeasure ? columnMetaData.displayName : children.value,
                            "ref": host.createSelectionIdBuilder().withCategory(DataLayer.getCategoryColumn(children.identity, columnMetaData), 0)
                                .createSelectionId()
                        };
                    }
                    column.level = level;
                    if (columnMetaData && columnMetaData.isMeasure) {
                        column.isMeasure = true;
                    }
                    if (children.children) {
                        column.children = children.children.map(child => DataLayer.getDataSourceMatrixColumn(child, levels, host));
                    }
                    if (children.values) {
                        column.values = Object.keys(children.values).map(key => children.values[key].value);
                    }
                    return column;
                }


                public static getCategoryColumn(identity, source: DataViewMetadataColumn) {
                    const categoryColumn: DataViewCategoryColumn = {
                        source: source,
                        values: null,
                        identity: [identity],
                    };
                    return categoryColumn;
                }

                static getCategoricalData(dataView: DataView, host: IVisualHost, dataLayerConfig: any = {}, mergePropsConfig: any = [], bifrostProperty): Categorical.Data {
                    let measures = DataLayer.getDataSourceMeasures(dataView);
                    let dimensions = DataLayer.getDataSourceDimensions(dataView);
                    let groupDimension = DataLayer.getDataSourceGroupDimensions(dataView);
                    mergePropsConfig = DataLayer.updateMergePropsConfig(dataView, mergePropsConfig);

                    mergePropsConfig = DataLayer.filterMergePropsConfig(dataView, mergePropsConfig);
                    let objects = DataViewSettingsUtils.getDataViewObjects({ dataView, measures, dimensions, host, mergePropsConfig, bifrostProperty });
                    let categoricalData = {
                        rows: dataLayerConfig.tableRequired ? DataLayer.getDataSourceRows(dataView, host) : null,
                        columns: dataLayerConfig.tableRequired ? DataLayer.getDataSourceRowHeader(dataView) : null,
                        dimensions,
                        measures,
                        groupDimension,
                        objects
                    } as Categorical.Data;
                    return categoricalData;
                }

                static getDataSourceGroupDimensions(dataView: DataView) {
                    const values = dataView.categorical.values;
                    if (values && values.source && typeof values.grouped === "function") {
                        const groupedDimension = values.grouped();
                        return [{
                            "id": values.source.queryName.replace(/ /g, "").replace(/\./g, "_"),
                            "name": values.source.queryName,
                            "label": values.source.displayName,
                            "role": values.source.roles,
                            "values": groupedDimension.map(member => member.name)
                        }]
                    }
                    return [];
                }
                static updateMergePropsConfig(dataView: DataView, mergePropsConfig: MergeProp[]) {
                    let newMergedProps: MergeProp[] = [];

                    mergePropsConfig = mergePropsConfig.filter(mergeProp => {
                        if (!mergeProp.sectionIterator) {
                            return true;
                        }
                        let categoriesLength =  dataView.categorical.categories ? dataView.categorical.categories.filter(category => {
                            return category.source.roles[mergeProp.role];
                        }).length : 0;

                        for (let i = 0; i < categoriesLength; i++) {
                            newMergedProps.push({
                                role: mergeProp.role,
                                properties: [{
                                    name: mergeProp.sectionIterator.property,
                                    section: mergeProp.sectionIterator.section,
                                    dimensionSection: mergeProp.sectionIterator.section + i,
                                }],
                                dimensionIndex: i
                            })
                        }

                    });
                    return mergePropsConfig.concat(newMergedProps);
                }

                static filterMergePropsConfig(dataView: DataView, mergePropsConfig) {
                    let categories = dataView.categorical.categories;
                    return categories ? mergePropsConfig.map(mergeProp => {
                        let roleDimensions = categories.filter(category => category.source.roles[mergeProp.role]).map(category => {
                            return category.source.queryName.replace(/ /g, "").replace(/\./g, "_");
                        });

                        if (roleDimensions.length > mergeProp.dimensionIndex && mergeProp.dimensionIndex > -1) {
                            mergeProp.dimensionId = roleDimensions[mergeProp.dimensionIndex];
                        }
                        return mergeProp;
                    }) : [];
                }


                static getDataSourceRows(dataView: DataView, host: IVisualHost): Categorical.Row[] {
                    const rowLength = dataView.categorical.values[0].values.length;
                    let rows = [];
                    for (let i = 0; i < rowLength; i++) {
                        let row = [];
                        let selectionId;
                        if (dataView.categorical.categories) {
                            dataView.categorical.categories.forEach(column => {
                                row.push(column.values[i]);
                            });
                            selectionId = host.createSelectionIdBuilder().withCategory(dataView.categorical.categories[0], i)
                                .createSelectionId();
                        }
                        dataView.categorical.values.forEach(column => {
                            row.push(column.values[i]);
                        });
                        rows.push({
                            "ref": selectionId,
                            "value": row
                        });
                    }
                    return rows;
                }

                static getDataSourceDimensions(dataView: DataView): Categorical.Dimension[] {
                    return dataView.categorical.categories ? dataView.categorical.categories
                        .map(category => {
                            return {
                                "id": category.source.queryName ? category.source.queryName.replace(/ /g, "").replace(/\./g, "_") : "",
                                "name": category.source.queryName,
                                "label": category.source.displayName,
                                "role": category.source.roles,
                                "values": category.values
                            } as Categorical.Dimension;
                        }) : [];
                }

                static getDataSourceMeasures(dataView: DataView): Categorical.Measure[] {
                    return dataView.categorical.values ? dataView.categorical.values
                        .map((valueColumn, index) => {
                            let groupNames = valueColumn.source.groupName ? [valueColumn.source.groupName] : [];
                            let id = valueColumn.source.queryName + (groupNames.length !== 0 ? "_" + groupNames.join("_") : "");
                            id = id.replace(/ /g, "").replace(/\./g, "_");
                            return {
                                "id": id,
                                "name": valueColumn.source.queryName,
                                "label": valueColumn.source.displayName,
                                "role": valueColumn.source.roles,
                                "values": valueColumn.values,
                                "highlight": valueColumn.highlights,
                                "groupNames": groupNames,
                                "minLocal": valueColumn.minLocal,
                                "maxLocal": valueColumn.maxLocal
                                //  "subtotal":valueColumn.subtotal,
                                //  "min":valueColumn.min,
                                //  "max":valueColumn.max,
                                //  "average":valueColumn.average
                            } as Categorical.Measure;
                        }) : [];
                }

                static getMetadata(dataView: DataView, host: IVisualHost): bifrost.Metadata {

                    let metadata: bifrost.Metadata = {
                        dimensions: [],
                        measures: []
                    };

                    let legendColumnsIds = DataLayer.getLegendColumns(dataView).map(column => column.queryName);
                    const addMetadata = (newColumn: DataViewMetadataColumn, columnType) => {
                        if (metadata[columnType].filter(column => column.name === newColumn.queryName).length === 0) {

                            metadata[columnType].push({
                                "name": newColumn.queryName,
                                "role": newColumn.roles,
                                "label": newColumn.displayName,
                                "type": newColumn.type,
                                "format": newColumn.format,
                                "groupBy": legendColumnsIds
                            });
                        }
                    };


                    dataView.metadata.columns.forEach(column => {
                        column.isMeasure ? addMetadata(column, "measures") : addMetadata(column, "dimensions");
                    });

                    return metadata;
                }

                static getDataSourceRowHeader(dataView: DataView): bifrost.Column[] {
                    let dimensionHeaders: any[] = dataView.categorical.categories ? dataView.categorical.categories.map(column => {
                        return {
                            "name": column.source.queryName,
                            "type": column.source.type,
                            "role": column.source.roles,
                            "label": column.source.displayName
                        } as bifrost.Column;
                    }) : [];
                    let valueHeaders: any[] = dataView.categorical.values.map((column) => {
                        return {
                            "role": column.source.roles,
                            "name": column.source.queryName,
                            "groupNames": column.source.groupName ? [column.source.groupName] : [],
                            "label": column.source.displayName,
                            "format": column.source.format,
                            "type": column.source.type
                        } as bifrost.Column;
                    });
                    return dimensionHeaders.concat(valueHeaders);
                }

                static getLegendColumns = (dataView: DataView) => {
                    if (!dataView.categorical) {
                        return [];
                    }
                    let categoryRole = dataView.categorical.categories ? Object.keys(dataView.categorical.categories[0].source.roles)[0] : "";
                    return dataView.metadata.columns.filter(column => !column.isMeasure && !column.roles[categoryRole]);
                }

            }

        }
    }
}


module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    import IVisualSelectionId = powerbi.visuals.ISelectionId;
    export namespace bifrost {
        "use strict";
        export class SelectionIdBuilder {
            private host: IVisualHost;
            private dataView: DataView;
            private groupedItems: DataViewValueColumnGroup[];
            private selectionManager: ISelectionManager;
            constructor(options: VisualConstructorOptions) {
                this.host = options.host;
                this.selectionManager = options.host.createSelectionManager();
            }

            public setDataView(data: DataView) {
                if (!data) {
                    throw new Error('Dataview mandatatory');
                }
                this.dataView = data;
                const categorical = data.categorical;
                if(categorical && categorical.values && typeof categorical.values.grouped === "function") {
                    this.groupedItems = categorical.values.grouped();
                } else {
                    this.groupedItems = [];
                }
            }

            public getSelectionId(options) {
                let builder = this.host.createSelectionIdBuilder();

                if (options.measureName) {
                    if (Array.isArray(options.measureName)) {
                        options.measureName.forEach(name => {
                            builder.withMeasure(name);
                        });
                    }
                    else {
                        builder = builder.withMeasure(options.measureName);
                    }
                }
                if (options.categoricalIndex !== undefined && options.categoricalMemberIndex !== undefined) {
                    if (Array.isArray(options.categoricalIndex)) {
                        options.categoricalIndex.forEach((cIndex, i) => {
                            let category = this.dataView.categorical.categories[cIndex];
                            builder = builder.withCategory(category, options.categoricalMemberIndex[i]);
                        });
                    }
                    else {
                        let category = this.dataView.categorical.categories[options.categoricalIndex];

                        builder = builder.withCategory(category, options.categoricalMemberIndex);
                    }
                }
                if (options.seriesIndex !== undefined && this.dataView.categorical) {
                    let categoricalValues = this.dataView.categorical.values;
                    
                    if (Array.isArray(options.seriesIndex)) {
                        options.seriesIndex.forEach(sIndex => {
                            const groupName = categoricalValues[sIndex].source.groupName;
                            let legendItems = this.groupedItems.filter(group => group.name === groupName)[0];
        
                            builder = builder.withSeries(
                                categoricalValues, legendItems
                            );
                        });
                    }
                    else {
                        const groupName = categoricalValues[options.seriesIndex].source.groupName;
                        let legendItems = this.groupedItems.filter(group => group.name === groupName)[0];    
                        builder = builder.withSeries(
                            categoricalValues, legendItems
                        );
                    }
                }

                return builder.createSelectionId();
            }

            public select(ISelectionId: IVisualSelectionId[], multiSelect: boolean): IPromise<ISelectionId[]> {
                return this.selectionManager.select(ISelectionId, multiSelect);
            }

            public clear(): IPromise<{}> {
                return this.selectionManager.clear();
            }

            public showContextMenu(selectionId, clientX, clientY) {
                this.selectionManager.showContextMenu(selectionId, {
                    x: clientX,
                    y: clientY
                });                
            }

            public getSelectionIds(): ISelectionId[] {
                return this.selectionManager.getSelectionIds();                
            }

            public hasSelection() : boolean {
                return this.selectionManager.hasSelection();
            }

            public registerOnSelectCallback(callBack: (ids: ISelectionId[]) => void) {
                this.selectionManager.registerOnSelectCallback(callBack);
            }
        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    import valueFormatter = powerbi.extensibility.utils.formatting.valueFormatter;
    export namespace bifrost {
        export namespace visual {
            "use strict";
            let Sentry = (window as any).Sentry;
            export class BifrostVisual implements IVisual {
                private target: HTMLElement;
                private visualSettings: VisualSettings;
                private trialLibrary: VBITrialLibrary;
                private renderer: any;
                private editorInitializer: EditorInitializer;
                private selectionManager: ISelectionManager;
                private host: IVisualHost;
                private selectionIdBuilder: SelectionIdBuilder;
                private settingsSchemaBuilder: SettingsUISchemaBuilder;
                private isEditorOpen: boolean;
                private landingPageConfig: LandingPageConfig = {
                    title: 'VisualBI Visuals',
                    content: 'Custom Visuals by VisualBI',
                    urlInfo: 'More at ',
                    url: 'https://www.visualbi.com'
                };
                private config :InitComponentConfig;
                private previousViewMode: ViewMode;
                public static bifrostPropertyName = "bifrost";
                public static bifrostSectionName = "bifrostSection";
                private timeout: number;
                private data: Data;

                constructor(options: VisualConstructorOptions) {
                    try {
                        this.target = options.element;
                        this.selectionManager = options.host.createSelectionManager();
                        this.host = options.host;
                        this.selectionIdBuilder = new SelectionIdBuilder(options);
                        this.settingsSchemaBuilder = new SettingsUISchemaBuilder(this.getBifrostPropertyValue.bind(this));
                        this.isEditorOpen = false;
                    }
                    catch (e) {
                        if (Sentry) {
                            Sentry.captureException(e);
                        }
                    }
                }

                @logExceptions()
                protected initComponent(renderer: any, config: InitComponentConfig) {
                    this.renderer = renderer;
                    this.editorInitializer = new EditorInitializer(this.target, this);
                    this.config = config;
                    if (this.config.useDefaultLandingPage) {
                        this.config.landingPageConfig = this.landingPageConfig;
                    }
                    this.trialLibrary = new VBITrialLibrary(this.editorInitializer.componentContainer, this.host);
                }

                protected getComponentContainer(): HTMLElement {
                    if (this.editorInitializer) {
                        return this.editorInitializer.getComponentContainer();
                    } else {
                        return null;
                    }
                }

                protected getCFRules() {
                    const { conditionalFormattingProperty } = this.config;
                    if (!conditionalFormattingProperty) {
                        return [];
                    }
                    const { sectionId = null, propertyId = null } = conditionalFormattingProperty;
                    if (sectionId && propertyId && this.visualSettings[sectionId]) {
                        return this.visualSettings[sectionId][propertyId] || [];
                    }
                    return [];
                }


                private applyConditionalFormattingRules(dataViews: DataView[]) {
                    // Conditional formatting will work only for Categorical Data.
                    if (this.data.categorical && this.data.categorical.measures) {
                        const cfRules = this.getCFRules();
                        const conditionalFormatting = new ConditionalFormatting(dataViews[0], this.data, cfRules || [], ".");
                        this.data.categorical.measures.forEach((measure, index) => {
                            measure.conditionalFormatting = conditionalFormatting.getColors(index);
                        });
                    }
                }

                private isResizeEvent(options) {
                    const isViewModeChange = this.isViewModeChange(options.viewMode);
                    if ((options.type === VisualUpdateType.Resize || options.type === 36 || options.type === VisualUpdateType.ResizeEnd) && !isViewModeChange) {
                        return true;
                    }
                    return false;
                }

                private handelResize(options) {
                    const resizeHandler = this.config.resizeHandler;
                    if (typeof resizeHandler === "object") {
                        this.debounce(resizeHandler.callBack, resizeHandler.timeOut === undefined ? 200 : resizeHandler.timeOut);
                        return true;
                    }
                    return false;
                }

                private updateSentry() {
                    if (Sentry) {
                        Sentry.configureScope(scope => {
                            scope.setExtra('settings', this.visualSettings);
                        });
                    }
                }

                @logExceptions()
                public update(options: VisualUpdateOptions) {
                    if ((!options.dataViews || !options.dataViews.length) && this.config.useDefaultLandingPage) {
                        UIIndicators.addLandingPage(this.config, this.host, this.target);
                        return;
                    }else if (!options.dataViews || !options.dataViews.length) {
                        let renderOptions = {
                            data: null,
                            element: this.editorInitializer.getComponentContainer(),
                            selectionManager: null,
                            selectionIdBuilder: null,
                            highContrast: bifrost.HighContrast.getContrastConfig(this.host),
                            updateType: options.type,
                            settings: VisualSettings.getDefault(),
                            viewMode: options.viewMode,
                            sampleVisual: true
                        };
                        this.renderer(renderOptions);
                        return;
                    } else {
                        UIIndicators.removeLandingPage(this.target);
                    }
                  

                    this.visualSettings = BifrostVisual.parseSettings(options && options.dataViews && options.dataViews[0]);

                    const isResizeEvent = this.isResizeEvent(options);
                    if (isResizeEvent && this.handelResize(options)) {
                        return;
                    }

                    if (this.editorInitializer.getComponentContainer().innerHTML === "") {
                        UIIndicators.showLoading(this.editorInitializer.getComponentContainer());
                    }


                    this.updateSentry();
                    this.data = bifrost.data.DataLayer.formatData({
                        dataView: options.dataViews[0],
                        host: this.host,
                        dataLayerConfig: this.config.dataLayer,
                        mergePropsConfig: this.config.mergeProps,
                        bifrostProperty: {
                            set: this.updateBifrostPropertyValue.bind(this),
                            get: this.getBifrostPropertyValue.bind(this)
                        }
                    });

                    if(this.addRemoveMeasureKPI()){
                        return;
                    }

                    this.applyConditionalFormattingRules(options.dataViews);
                    this.selectionIdBuilder.setDataView(options.dataViews[0]);
                    this.settingsSchemaBuilder.setDataView(this.host, options.dataViews[0], this.data, this.selectionIdBuilder);


                    const renderOptions = {
                        data: this.data,
                        element: this.editorInitializer.getComponentContainer(),
                        selectionManager: this.selectionManager,
                        selectionIdBuilder: this.selectionIdBuilder,
                        highContrast: bifrost.HighContrast.getContrastConfig(this.host),
                        updateType: options.type,
                        settings: this.visualSettings,
                        viewMode: options.viewMode,
                        sampleVisual: false
                    } as bifrost.RenderOptions;
                   
                    isResizeEvent ? this.debounce(this.renderer, 200, renderOptions) : this.renderer(renderOptions);

                    let isViewMode = options.viewMode === ViewMode.View;
                    
                    if(!isViewMode){
                        this.editorInitializer.componentContainer.classList.add("edit-mode");
                    }
                    else{
                        this.editorInitializer.componentContainer.classList.remove("edit-mode");
                    }

                    if (isViewMode) {
                        this.isEditorOpen = false;
                    }
                    else if (options.editMode == EditMode.Advanced) {
                        this.isEditorOpen = true;
                    }
                    this.trialLibrary.checkLicence(this.visualSettings, options.viewMode);
                   
                    this.addEditIcon(options, isViewMode);
                    this.renderEditor(options);
                }

                private addRemoveMeasureKPI() {
                    let isOnlyMeasureAdded = BifrostVisual.getSingleMeasure(this.data);
                    if (!this.config.isMeasureComponent && isOnlyMeasureAdded) {
                        UIIndicators.showSingleMeasureKPI(this.editorInitializer.getComponentContainer(), isOnlyMeasureAdded);
                        return true;
                    }
                    else {
                        UIIndicators.removeSingleMeasureKPI();
                        return false;
                    }
                }
                protected static parseSettings(dataView: DataView): VisualSettings {
                    return VisualSettings.parse(dataView) as VisualSettings;
                }

                private addEditIcon(options, isViewMode) {
                    if (this.config.editor) {
                        UIIndicators.addEditIcon({
                            element: this.target,
                            onClick: () => {
                                this.isEditorOpen = !this.isEditorOpen;
                                this.renderEditor(options);
                            },
                            isRemove: isViewMode,
                            isCloseIcon: this.isEditorOpen
                        });
                    }
                }

                public updateProperty(sectionName, propertyName, value) {
                    this.host.persistProperties({
                        merge: [
                            {
                                objectName: sectionName,
                                selector: null,
                                properties: {
                                    [propertyName]: value
                                }
                            } as VisualObjectInstancesToPersist
                        ]
                    } as VisualObjectInstancesToPersist);
                }

                public updateBifrostPropertyValue(propertyName, value) {

                    try {
                        let bifrostPropertyJSONString = this.visualSettings[BifrostVisual.bifrostSectionName][BifrostVisual.bifrostPropertyName];
                        let bifrostPropertyJSON = JSON.parse(bifrostPropertyJSONString || "{}");
                        bifrostPropertyJSON[propertyName] = value;
                        let newValue = JSON.stringify(bifrostPropertyJSON);
                        if (bifrostPropertyJSONString !== newValue) {
                            this.updateProperty(BifrostVisual.bifrostSectionName, BifrostVisual.bifrostPropertyName, newValue);
                        }
                    }
                    catch (e) {
                        console.log(e);
                    }
                }

                public getBifrostPropertyValue(propertyName) {
                    try {
                        let bifrostPropertyJSONString = this.visualSettings[BifrostVisual.bifrostSectionName][BifrostVisual.bifrostPropertyName];
                        let bifrostPropertyJSON = JSON.parse(bifrostPropertyJSONString || "{}");
                        return bifrostPropertyJSON[propertyName];
                    }
                    catch (e) { }
                }

                private renderEditor(options) {
                    let editorConfiguration = this.config.getEditorConfiguration ? this.config.getEditorConfiguration() || {} : {};
                    if (this.isEditorOpen) {
                        this.editorInitializer.renderEditor({ ...options, bifrostData: this.data, valueFormatter: valueFormatter }, editorConfiguration);
                    }
                    else {
                        this.editorInitializer.removeEditor();
                    }
                }


                protected static getSingleMeasure(data: bifrost.Data) {
                    if (data.metadata.dimensions.length === 0 && data.metadata.measures.length !== 0) {
                        let value = data.categorical ? data.categorical.measures[0].values[0] : data.matrix.rows[0].values[0];
                        let formatter = valueFormatter.create({ format: data.metadata.measures[0].format });
                        return {
                            value: formatter.format(value),
                            label: data.metadata.measures[0].label
                        };
                    }
                    return null;
                }

                private isViewModeChange(viewMode) {
                    let isViewModeChange = false;
                    if (this.previousViewMode !== undefined && this.previousViewMode !== viewMode) {
                        isViewModeChange = true;
                    }
                    this.previousViewMode = viewMode;
                    return isViewModeChange;
                }

                @logExceptions()
                public enumerateObjectInstances(options: EnumerateVisualObjectInstancesOptions): VisualObjectInstance[] | VisualObjectInstanceEnumerationObject {

                    // Hide bifrost section
                    if (options.objectName === BifrostVisual.bifrostSectionName) {
                        return [];
                    }
                    if (options.objectName === VBITrialLibrary.LICENSE_PROPERTY_NAME.section) {
                        return this.getSettingsSchemaForLicense();
                    }

                    let settingsUISchemaConfig = this.config.getSettingsUIConfiguration ? this.config.getSettingsUIConfiguration() || [] : [];

                    return this.settingsSchemaBuilder.getEnumerateObjects(options, this.visualSettings, settingsUISchemaConfig);
                }
                public debounce(func: Function, wait: number, ...args) {
                    let later = () => {
                        this.timeout = null;
                        func.call(this, ...args);
                    };
                    clearTimeout(this.timeout);
                    this.timeout = setTimeout(later, wait, args);
                }

                public getSettingsSchemaForLicense() {
                    let settings = this.visualSettings;
                    const LICENSE_PROPERTY_NAME = VBITrialLibrary.LICENSE_PROPERTY_NAME;
                    const licenseKey = settings[LICENSE_PROPERTY_NAME.section] ? settings[LICENSE_PROPERTY_NAME.section][LICENSE_PROPERTY_NAME.property] : "";
                    let settingsSchema = [];
                    if (!LICENSE_KEY) {
                        settingsSchema.push({
                            objectName: LICENSE_PROPERTY_NAME.section,
                            properties: {
                                [LICENSE_PROPERTY_NAME.property]: licenseKey
                            }
                        });
                    }
                    else if (CUSTOMER_NAME) {
                        settingsSchema.push({
                            objectName: LICENSE_PROPERTY_NAME.section,
                            properties: {
                                "customer": CUSTOMER_NAME
                            }
                        });
                    }
                    return settingsSchema;
                }
            }
        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        export class DataSelection {
            static getSelectionValue(data: bifrost.Data, selections: Categorical.Selection[]) {

                if (data.categorical) {
                    return selections.map(selection => DataSelection.getSelectionValueFromCategoricalData(data.categorical, selection));
                }
            }

            static getSelectionValueFromCategoricalData(data: Categorical.Data, selection: Categorical.Selection): Categorical.SelectionValue {
                if (selection.dimensions.length !== 0) {
                    let selectionIndexes = [];
                    let selectedDimensions = [];
                    let selectedDimensionIds = selection.dimensions.map(dimension => dimension.id);

                    // Extracting dimensions that are in selection
                    data.dimensions.forEach((dimension) => {
                        let dimensionIndex = selectedDimensionIds.indexOf(dimension.id);
                        if (dimensionIndex !== -1) {
                            selectedDimensions.push({
                                ...dimension,
                                index: dimensionIndex
                            });
                        }
                    });

                    // Invalid Selection
                    if (selectedDimensions.length !== selection.dimensions.length) {
                        return null;
                    }

                    // Extraction selectionIndexes
                    let rowLength = selectedDimensions[0].values.length;
                    let selectedValuesLength = selection.dimensions[0].values.length;
                    for (let memberIndex = 0; memberIndex < rowLength; memberIndex++) {
                        let addIndex = false;
                        for (let selectedValueIndex = 0; selectedValueIndex < selectedValuesLength && !addIndex; selectedValueIndex++) {
                            let filteredValuesLength = selectedDimensions.filter(selectedDimension => {
                                if (!selectedDimension.values[memberIndex]) {
                                    return false;
                                }
                                return selection.dimensions[selectedDimension.index].values[selectedValueIndex] === selectedDimension.values[memberIndex].toString();
                            }).length;
                            if (filteredValuesLength === selectedDimensions.length) {
                                addIndex = true;
                            }
                        }
                        if (addIndex) {
                            selectionIndexes.push(memberIndex);
                        }
                    }

                    let selectedMeasures = data.measures.filter(measure => selection.measureIds.indexOf(measure.id) !== -1);

                    // Forming the skeleton of selectionValue
                    let selectionValue: Categorical.SelectionValue = {
                        dimension: selectedDimensions.map((dimension) => {
                            delete dimension.index;
                            return {
                                ...dimension,
                                values: []
                            };
                        }),
                        measures: selectedMeasures.map(measure => {
                            return {
                                ...measure,
                                values: []
                            };
                        }),
                        selectionIndexes
                    };

                    // Adding the selected values to selectionValue
                    selectionIndexes.forEach((selectionIndex) => {
                        selectedDimensions.forEach((dimension, index) => {
                            selectionValue.dimension[index].values.push(dimension.values[selectionIndex]);
                        });
                        selectedMeasures.forEach((measure, index) => {
                            selectionValue.measures[index].values.push(measure.values[selectionIndex]);
                        });
                    });

                    return selectionValue;
                }
                else if (selection.measureIds.length !== 0) {
                    return {
                        dimension: [],
                        measures: data.measures.filter(measure => selection.measureIds.indexOf(measure.id) !== -1),
                        selectionIndexes: []
                    };
                }
                else {
                    return null;
                }
            }

        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662.bifrost  {
    export class EditorInitializer {
        private visualInstance: any;
        private editorInstance: any;
        public componentContainer: HTMLElement;
        public editorContainer: HTMLElement;
        private listener: any;
        private modalContainer: HTMLElement;
        private editorBody: HTMLElement;
        constructor(target: HTMLElement, visualInstance) {
            this.componentContainer = document.createElement('div'),
            this.editorContainer = document.createElement('div');
            this.visualInstance = visualInstance;
            this.editorInstance = (<any>window).Editor;
            this.componentContainer.classList.add('plot-area');
            this.editorContainer.classList.add('editor');
            this.editorContainer.setAttribute('id', 'editorContainer');
            target.appendChild(this.editorContainer);
            target.appendChild(this.componentContainer);
            this.modalContainer = document.createElement("div");
            this.modalContainer.setAttribute("id","editor-modal-container");
            this.editorBody =  document.createElement("div");
            this.editorBody.setAttribute("id","editor-body");
            this.editorContainer.appendChild(this.modalContainer);
            this.editorContainer.appendChild(this.editorBody);
            this.listener = this.onEditorPropertyChangeListener.bind(this);
        }

        public getComponentContainer() {
            return this.componentContainer;
        }

        public getEditorContainer() {
            return this.editorContainer;
        }
        public getPropertyValue = (property) => {
            if (!property || !property.sectionId || !property.propertyId) {
                return null;
            }
            let objects = this.visualInstance.visualSettings;
            if (objects) {
                let propertyValue = objects[property.sectionId] ? objects[property.sectionId][property.propertyId] : null;
                if(propertyValue && typeof propertyValue === "string") {
                    return JSON.parse(propertyValue);
                } 
                return propertyValue;
            } else {
                return null;
            }
        }
        private onEditorPropertyChangeListener(change, meta) {
            let updatedProperty = {}, host = this.visualInstance.host;

            updatedProperty[meta.propertyId] = JSON.stringify(change.newValue);
            host.persistProperties({
                merge: [
                    {
                        objectName: meta.sectionId,
                        selector: null,
                        properties: updatedProperty
                    } as VisualObjectInstancesToPersist
                ]
            } as VisualObjectInstancesToPersist);
        }

        public renderEditor(options, config) {
            if (this.editorInstance) {
                this.componentContainer.classList.add('resize-chart');
                this.editorContainer.classList.add('editor--show');                
                options = { ...options, configurations: config, listener: this.listener, getPropertyValue: this.getPropertyValue};
                this.editorInstance.loadEditor.call(this.visualInstance, this.editorBody, options);    
            }

        }

        public removeEditor() {
            if (this.editorInstance) {
                this.componentContainer.classList.remove('resize-chart');
                this.editorContainer.classList.remove('editor--show');
                this.editorInstance.removeEditor(this.editorBody);
            }
        }
    }
}

module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662.bifrost  {
    export class VBITrialLibrary {

        static LICENSE_PROPERTY_NAME = {
            section: "license",
            property: "key"
        };
        private previousLicenceKey = "_X_X_";
        private licenceStatus: LicenseStatus;
        private element: HTMLElement;
        private host: IVisualHost;
        private freemiumMessageOverlay;
        static smokeScreenStatusMessages = {
            "expired": {
                "message": "Your license key has been expired.",
                "urlInfo": "Renew your license at:",
                "url": "https://products.visualbi.com/power-bi/"
            },
            "noLicense": {
                "message": "You have used pro properties, please provide a valid license key.",
                "urlInfo": "Get a license at:",
                "url": "https://products.visualbi.com/power-bi/"
            },
            "info": {
                "message": "Visual developed by VisualBI Solutions.",
                "urlInfo": "Get a license at:",
                "url": "https://products.visualbi.com/power-bi/"
            },
            "invalid": {
                "message": "The provided license key was invalid, please provide a valid one ",
                "urlInfo": "Get a license at:",
                "url": "https://products.visualbi.com/power-bi/"
            },
            "hardStop": {
                "message": "This version of visual is no more supported, please update to new version",
                "urlInfo": "Download new version at:",
                "url": "https://products.visualbi.com/power-bi/"
            }
        }

        static messageTypeModalClassMap = {
            "expired": "licence-expired",
            "info": "no-licence",
            "noLicense": "no-license-pro-used",
            "invalid": "invalid-licence",
            "valid":"pro-user"
        }

        static idLinkMap = {
            "how-to-use":"https://visualbi.com",
            "release-notes":"https://visualbi.com",
            "key-features":"https://visualbi.com",
            "sample-report":"https://visualbi.com",
            "more-visuals":"https://visualbi.com",
            "give-feedback":"https://visualbi.com",
            "start-trail-btn":"https://visualbi.com",
            "renew-license-btn":"https://visualbi.com",
            "vbi-support-link":"http://support.visualbi.com/support/login",
            "logo-container-licence":"https://visualbi.com/",
            "buy-licence-link":"https://visualbi.com/"
        }
        constructor(element, host) {
            this.element = element;
            this.host = host;
            this.licenceStatus = {
                isNoLicence: true,
                valid: false
            }
        }

        private updateLicenceModalLinks(){
            Object.keys(VBITrialLibrary.idLinkMap).forEach(id =>{
               let element = document.getElementById(id);
               if(element){
                   element.addEventListener("click", ()=>{
                       this.host.launchUrl(VBITrialLibrary.idLinkMap[id]);
                   });
               }
            });
        }
        private updateLicenceStatus(licenseKey) {
            if (this.previousLicenceKey === licenseKey) {
                return true;
            }
            this.previousLicenceKey = licenseKey;
            return this.checkLicense(licenseKey).then((licenseDetail: LicenseStatus) => {
                this.licenceStatus = licenseDetail;
            })
        }

        public checkLicence = (settings, viewMode) => {
            const LICENSE_PROPERTY_NAME = VBITrialLibrary.LICENSE_PROPERTY_NAME;
            const licenseKey = settings[LICENSE_PROPERTY_NAME.section] ? settings[LICENSE_PROPERTY_NAME.section][LICENSE_PROPERTY_NAME.property] : "";
            const isProPropertiesUsed = this.checkForProProperties(settings);
            const isViewMode = viewMode === ViewMode.View;
            const status = this.updateLicenceStatus(licenseKey);
            if (status === true) {
                this.attachTrailIndicators(isProPropertiesUsed, isViewMode);
            }
            else {
                status.then(() => {
                    this.attachTrailIndicators(isProPropertiesUsed, isViewMode);
                });
            }

        }

        private attachTrailIndicators(isProPropertiesUsed, isViewMode) {
            let licenseStatus = this.licenceStatus;
            this.removeAllTrialIndicators();

            if (licenseStatus.valid) {
                if(!isViewMode){
                    this.addRemoveInfoIcon(false, "valid");
                }
                return true;
            }

            this.addRemoveLogo(isViewMode);

            // HardStop Visual
            if (licenseStatus.isHardStop) {
                this.addRemoveLicenseSmokeScreen(false, "hardStop");
                return false;
            }

            let messageType = this.getMessageType(licenseStatus);

            if (!isProPropertiesUsed) {
                this.addRemoveInfoIcon(false, licenseStatus.isNoLicence ? "info" : messageType);
            }

            if (isViewMode && isProPropertiesUsed) {
                this.addRemoveLicenseSmokeScreen(false, messageType);
            }

            if (!isViewMode && isProPropertiesUsed) {
                this.addRemoveLicenseAlertIcon(false, messageType);
            }
            
            return false;
        }

        private getMessageType(licenceStatus: LicenseStatus) {
            if (licenceStatus.isNoLicence) {
                return "noLicense";
            }
            if (licenceStatus.expired) {
                return "expired";
            }
            if (!licenceStatus.valid) {
                return "invalid";
            }
            return "";
        }

        private removeAllTrialIndicators() {
            this.addRemoveLogo(true);
            this.addRemoveInfoIcon(true);
            this.addRemoveLicenseSmokeScreen(true);
            this.addRemoveLicenseAlertIcon(true);
            this.addRemoveLicenceModal(true);
        }
        private checkForProProperties = (settings) => {
            let defaults = VisualSettings.getDefault();
            for (let property of propProperties) {
                let propertyValue = settings[property.section][property.name];
                if (typeof property.checkUsage === "function") {
                    if (property.checkUsage(propertyValue)) {
                        return true
                    } else {
                        continue;
                    }
                }
                if (defaults[property.section][property.name] !== propertyValue) {
                    return true;
                }

            }
            return false;
        }

        private checkLicense = (license): Promise<LicenseStatus> => {
            return fetch(`https://products.visualbi.com/?api-request=licence_check&licence_key=${license}&visual_version=${VISUAL_VERSION}&visual_name=${COMPONENT_NAME}`)
                .then(function (response) {
                    return response.json();
                })
                .then(function (licenseStatus) {
                    return {
                        valid: licenseStatus.code === "200",
                        expired: licenseStatus.code === "140",
                        isHardStop: licenseStatus.hardStop === "true",
                        isNoLicence: license === ""
                    }
                });
        }



        private addRemoveLogo = (isRemove: boolean = false) => {
            let logoElement = document.getElementById('vbi-logo');
            if (!UIIndicators.checkElementStatus(logoElement, isRemove)) {
                return;
            }
            logoElement = document.createElement('div');
            logoElement.setAttribute('class', 'vbi-logo background-image vbi-logo-gray right-bottom-ps');
            const linkElement = document.createElement('a');
            linkElement.setAttribute('target', '_blank');
            linkElement.setAttribute('href', 'https://visualbi.com');
            linkElement.appendChild(logoElement);
            linkElement.setAttribute('id', 'vbi-logo');
            logoElement.addEventListener('click', () => {
                this.host.launchUrl("https://visualbi.com");
            })
            this.element.appendChild(linkElement);
        }


        private addRemoveLicenseSmokeScreen = (
            isRemove: boolean = false,
            messageType: string = "invalid"
        ) => {

            let modal = document.getElementById('vbi-info-modal');
            if (!UIIndicators.checkElementStatus(modal, isRemove)) {
                return;
            }

            let statusMessage = VBITrialLibrary.smokeScreenStatusMessages[messageType];
            modal = document.createElement('div');
            modal.setAttribute('class', 'vbi-smoke-screen');
            modal.setAttribute('id', 'vbi-info-modal');
            modal.innerHTML =
                `<div class="info-container">
                <div class="info-message">
                <div class="vbi-logo vbi-logo-color background-image error-indicator"></div>
                        <div class="error-span">${statusMessage.message}</div>
                        <div class="error-span vbi-error-url" id="vbi-error-url">${statusMessage.urlInfo} <a target="_blank" href="${statusMessage.url}">${statusMessage.url}</a></div>
                </div>
            </div>`;
            modal.getElementsByClassName("vbi-error-url")[0].addEventListener("click", () => {
                this.host.launchUrl(statusMessage.url)
            });
            this.element.appendChild(modal);
        }



        private addRemoveInfoIcon(isRemove: boolean = false, messageType: string = "info") {
            let infoIcon = document.getElementById('vbi-info-icon');
            if (!UIIndicators.checkElementStatus(infoIcon, isRemove)) {
                return;
            }
            infoIcon = document.createElement('div');
            infoIcon.setAttribute('class', 'vbi-info-icon background-image right-top-ps');
            infoIcon.setAttribute('id', 'vbi-info-icon');
            infoIcon.setAttribute('title', 'Info');
            infoIcon.addEventListener("click", () => {
                let infoModal = document.getElementById('vbi-info-modal');
                this.addRemoveLicenceModal(infoModal ? true : false, messageType);
            })
            this.element.appendChild(infoIcon);
        }

        private addRemoveLicenseAlertIcon(isRemove: boolean = false, messageType: string = "invalid") {
            let licenseAlertIcon = document.getElementById('vbi-license-alert-icon');
            if (!UIIndicators.checkElementStatus(licenseAlertIcon, isRemove)) {
                return;
            }
            licenseAlertIcon = document.createElement('div');
            licenseAlertIcon.setAttribute('class', 'vbi-license-alert-icon background-image');
            licenseAlertIcon.setAttribute('id', 'vbi-license-alert-icon');
            licenseAlertIcon.setAttribute('title', 'Invalid License');
            licenseAlertIcon.addEventListener('click', () => {
                let licenceModal = document.getElementById('vbi-info-modal');
                this.addRemoveLicenceModal(licenceModal ? true : false, messageType);
            })
            this.element.appendChild(licenseAlertIcon);
        }

        private addRemoveLicenceModal(isRemove: boolean = false, messageType: string = "info") {
            let className = VBITrialLibrary.messageTypeModalClassMap[messageType];
            let licenceModal = document.getElementById('vbi-licence-modal');
            if (licenceModal) {
                licenceModal.setAttribute("class", "vbi-licence-modal " + className);
            }
            if (!UIIndicators.checkElementStatus(licenceModal, isRemove)) {
                return;
            }
            licenceModal = document.createElement("div");
            licenceModal.setAttribute("id", "vbi-licence-modal");
            licenceModal.setAttribute("class", "vbi-licence-modal " + className);
            licenceModal.innerHTML = `<div class="flex-container">
            <div class="vbi-licence-header vbi-licence-modal-item">
            <div title="Close"  class="modal-close-button close-icon-2 background-image"></div>
               <div class="chart-name"> ${COMPONENT_NAME} v${VISUAL_VERSION} </div>
               <div class="logo-container-licence">
                  <a target="_blank" href="https://visualbi.com/">
                     <div class="vbi-logo-licence" id="vbi-logo-licence">
                        <img src="data:image/png;base64,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"></img>
                     </div>
                  </a>
               </div>
            </div>
            <div class="vbi-licence-body vbi-licence-modal-item">
               <div class="info-menu vbi-licence-body-item">
                  <div class="menu-item" id="how-to-use">
                     How To Use
                  </div>
                  <div class="menu-item" id="release-notes">
                     Release Notes
                  </div>
                  <div class="menu-item" id="key-features">
                     Key Features
                  </div>
                  <div class="menu-item" id="sample-report">
                     Sample Report
                  </div>
                  <div class="menu-item" id="more-visuals">
                     More Visuals
                  </div>
                  <div class="menu-item" id="give-feedback">
                     Give Feedback
                  </div>
               </div>
               <div class="info-message-licence vbi-licence-body-item">
                  <div class="warning-message pro-used-msg">You have used pro feautres in your visual, please  provide a valid license.</div>
                  <div class="warning-message licence-expired-msg">Your Licence has been expired</div>
                  <div class="warning-message no-licence-msg">Thanks for choosing  ${COMPONENT_NAME} by VisualBI. Check out the pro features. </div>
                  <div class="warning-message thanks-msg">Thanks for choosing  ${COMPONENT_NAME} by VisualBI.</div>
                  <div class="warning-message invalid-licence-msg">The provided license key was invalid, please provide a valid one.</div>
                  <div class="buy-licence">
                     Don't have licence key.
                     <div class="email-ui">
                        <input placeholder="Email" id="start-trail-email"></input> 
                        <div class="free-trial-btn" id="start-trail-btn"> START YOUR TRAIL</div>
                     </div>
                     or <a href="https://products.visualbi.com/power-bi/" target="_blank" id="buy-licence-link">Buy License
                     </a>
                  </div>
                  <div class="renew-licence">
                  <div class="email-ui"><input placeholder="Email" id="renew-license-email"></input> <div class="free-trial-btn" id="renew-license-btn"> Renew License</div></div>
                  </div>
               </div>
            </div>
            <div class="footer vbi-licence-modal-item">
            <div class="feedback-link footer-item">
            Need more help <a target="_blank" id="vbi-support-link" href="http://support.visualbi.com/support/login">Contact Our Support</a> 
            </div>
            <div class="copy-rights footer-item"> Visual BI</div>
            </div></div>`;

            this.element.appendChild(licenceModal);
            licenceModal.getElementsByClassName("modal-close-button")[0].addEventListener("click", () => {
                this.addRemoveLicenceModal(true);
            });
            this.updateLicenceModalLinks();
        }

    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662.bifrost  {
    export class UIIndicators {
        static attachStyleForRVisual = (element: HTMLElement) => {
            if (document.getElementById("vbi-r-style")) {
                return;
            }
            element.innerHTML += `<style  id="vbi-r-style">
        .info-container{
            top: 0px;
            right: 40px;
            bottom: 40px;
            left: 40px;
            position: absolute;
        }
        <style>`;
        }

        static showLoading = (element: HTMLElement) => {
            if (document.getElementById("vbi-loading-indicator")) {
                return;
            }
            UIIndicators.removeElement("vbi-error-indicator");
            element.innerHTML += `<div class="info-container" id="vbi-loading-indicator">
                <div class="info-message">
                        <div class="loader"></div>
                    <div>
                        <div class="error-span">Loading Visual...</div>
                    </div>
                </div>
            </div>`;
        }

        static removeLandingPage(target) {
            let landingPageElement = target.getElementsByClassName('vbi-show-landing-page')[0];
            if (landingPageElement) {
                landingPageElement.remove();
            }
        }

        static addLandingPage(config, host, target) {
            if (config.landingPageConfig.html) {
                config.landingPageConfig.html.setAttribute('class', 'vbi-show-landing-page');
                target.getElementsByClassName('plot-area')[0].appendChild(config.landingPageConfig.html);                
            } else {
                let landingPageContainer = document.createElement("div");
                landingPageContainer.setAttribute('class', 'vbi-show-landing-page');
                landingPageContainer.setAttribute('id', 'vbi-landing-page');
                landingPageContainer.innerHTML =
                `<div title="Title" class="vbi-title-span">${config.landingPageConfig.title}</div>
                <div class="vbi-landing-message">
                    <div id="landing-page-logo" class="vbi-logo-div background-image"></div>
                    <div class="vbi-info-span">${config.landingPageConfig.content}</div>
                    <div class="vbi-info-span vbi-info-url" id="vbi-info-url">${config.landingPageConfig.urlInfo} <a target="_blank" href="${config.landingPageConfig.url}">${config.landingPageConfig.url}</a></div>
                </div>`;
                landingPageContainer.getElementsByClassName("vbi-info-url")[0].addEventListener("click", () => {
                    host.launchUrl(config.landingPageConfig.url);
                });
                target.getElementsByClassName('plot-area')[0].appendChild(landingPageContainer);                
                if (config.landingPageConfig.logoImage) {
                    document.getElementById('landing-page-logo').style.backgroundImage = "url('data:image/png;base64," + config.landingPageConfig.logoImage + "')";
                }
            }
        }

        static showSingleMeasureKPI = (element: HTMLElement, data) => {
            element.innerHTML = '';
            element.appendChild(UIIndicators.getKpi(data));
        }

        static removeSingleMeasureKPI(){
            let kpiTile = document.getElementById("vbi-single-measure-kpi");
            if(kpiTile){
                kpiTile.remove();
            }
        }
        static getKpi = (data) => {
            let kpi = document.createElement("div");
            kpi.setAttribute("class", "info-container vbi-kpi-tile");
            kpi.setAttribute("id", "vbi-single-measure-kpi");
            kpi.innerHTML = `<div class="info-message">
                    <div class="kpi-label">${data.label}</div>
                    <div class="kpi-value">${data.value}</div>
            </div>`;
            return kpi;
        }

        static showErrorMessage = (element: HTMLElement, errorMessage: string, errorUrl?: string) => {
            let errorMessageElement = document.getElementById("vbi-error-message");
            if (errorMessageElement) {
                errorMessageElement.innerHTML = errorMessage;
                UIIndicators.changeErrorUrl(errorUrl);
                return;
            }
            UIIndicators.removeElement("vbi-loading-indicator");
            element.innerHTML += `<div class="info-container" id="vbi-error-indicator" >
            <div class="info-message">
                    <div class="error-indicator">
                    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 23.625 23.625"><g><path style="fill:#030104;" d="M11.812,0C5.289,0,0,5.289,0,11.812s5.289,11.813,11.812,11.813s11.813-5.29,11.813-11.813 S18.335,0,11.812,0z M14.271,18.307c-0.608,0.24-1.092,0.422-1.455,0.548c-0.362,0.126-0.783,0.189-1.262,0.189 c-0.736,0-1.309-0.18-1.717-0.539s-0.611-0.814-0.611-1.367c0-0.215,0.015-0.435,0.045-0.659c0.031-0.224,0.08-0.476,0.147-0.759 l0.761-2.688c0.067-0.258,0.125-0.503,0.171-0.731c0.046-0.23,0.068-0.441,0.068-0.633c0-0.342-0.071-0.582-0.212-0.717 c-0.143-0.135-0.412-0.201-0.813-0.201c-0.196,0-0.398,0.029-0.605,0.09c-0.205,0.063-0.383,0.12-0.529,0.176l0.201-0.828 c0.498-0.203,0.975-0.377,1.43-0.521c0.455-0.146,0.885-0.218,1.29-0.218c0.731,0,1.295,0.178,1.692,0.53 c0.395,0.353,0.594,0.812,0.594,1.376c0,0.117-0.014,0.323-0.041,0.617c-0.027,0.295-0.078,0.564-0.152,0.811l-0.757,2.68 c-0.062,0.215-0.117,0.461-0.167,0.736c-0.049,0.275-0.073,0.485-0.073,0.626c0,0.356,0.079,0.599,0.239,0.728 c0.158,0.129,0.435,0.194,0.827,0.194c0.185,0,0.392-0.033,0.626-0.097c0.232-0.064,0.4-0.121,0.506-0.17L14.271,18.307z M14.137,7.429c-0.353,0.328-0.778,0.492-1.275,0.492c-0.496,0-0.924-0.164-1.28-0.492c-0.354-0.328-0.533-0.727-0.533-1.193 c0-0.465,0.18-0.865,0.533-1.196c0.356-0.332,0.784-0.497,1.28-0.497c0.497,0,0.923,0.165,1.275,0.497 c0.353,0.331,0.53,0.731,0.53,1.196C14.667,6.703,14.49,7.101,14.137,7.429z"/></g></svg>
                    </div>
                <div>
                    <div class="error-span" id="vbi-error-message">${errorMessage}</div></br>
                    <div class="error-span" id="vbi-error-url"></div>
                </div>
            </div>
        </div>`;
            UIIndicators.changeErrorUrl(errorUrl);
        }

        static changeErrorUrl = (url?: string) => {
            let errorMessageUrl = document.getElementById("vbi-error-url");
            errorMessageUrl.innerHTML = url ? `More details at <a target="_blank" href="${url}">${url}</a>` : "";
        }

        static removeElement = (elementId) => {
            // Removes an element from the document
            let element = document.getElementById(elementId);
            if (element) {
                element.parentNode.removeChild(element);
            }
        }
        static checkElementStatus(element, isRemove) {
            if (!element && !isRemove) {
                return true;
            }
            else if (element && isRemove) {
                element.remove();
            }
            return false;
        }


        static addEditIcon = ({element, onClick, isRemove = false, isCloseIcon=false}:{element :HTMLElement,onClick:any, isRemove:boolean , isCloseIcon:boolean}) => {
            let editIconElement = document.getElementById('vbi-edit-icon')
            // let iconClass = isCloseIcon ? 'close-icon-black' : 'edit-icon';
            let iconClass = 'edit-icon';
            if(editIconElement){
                editIconElement.setAttribute('class',`${iconClass} editor-icon background-image right-top-ps`)
            }
            if (!UIIndicators.checkElementStatus(editIconElement, isRemove)) {
                return;
            }
            let editIcon = document.createElement("img");
            editIcon.setAttribute("src","data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABcAAAAXCAQAAABKIxwrAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAAmJLR0QAAKqNIzIAAAAJcEhZcwAADdcAAA3XAUIom3gAAAAHdElNRQfjAg4IMxlYCHuXAAAA9UlEQVQ4y+XQvyuEcRwH8NfzHKEslEVHJoNBUnaymck/IVFyg/n8KJdusZHFZFQkSVw66gYGdcud/A833HDF4Ld77nnsPuOn1/v7fX+/JM2McyX3dvQkWqsqBhCad6s3iMUZw2pq1sCsyXj8pF0gLwsCD2HsyXkHQku6ZfGi0RrvCbHoUOr9hj6FeOxHoGwuCX8E2uRs/gW/Bcq2ovCKfc3PX7f9L/GomsGmbS7q60JM23Uk/Qs3ZETOsX5jSoY+NxvRNSClCN8CMZgJVzrBuDvp6M5f3adUnOlC1anH1p0hcGLBshEd6q5duCGOP6squFRUlziv0bBLdmNKIrAAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTktMDItMTRUMDc6NTE6MjUrMDE6MDC4dhKhAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE5LTAyLTE0VDA3OjUxOjI1KzAxOjAwySuqHQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAAASUVORK5CYII=");
            editIconElement = document.createElement('div');
            editIconElement.setAttribute('class', `${iconClass} editor-icon background-image right-top-ps`);
            editIconElement.setAttribute('id', 'vbi-edit-icon');
            editIconElement.setAttribute('title', 'Open/Close advanced editor');

            editIconElement.appendChild(editIcon);
            editIconElement.addEventListener('click', function(event) {
                let target = (event.currentTarget as HTMLElement);
                let currentClassName = target.getAttribute("class");
                // let iconClass = currentClassName.indexOf('edit-icon')!==-1 ? 'close-icon-black' : 'edit-icon';
                let iconClass = 'edit-icon';
                target.setAttribute('class',`${iconClass} editor-icon background-image right-top-ps`);
                onClick();
            });
            element.appendChild(editIconElement);
        }
    }
}
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
  import IVisualHost = powerbi.extensibility.visual.IVisualHost;
  export namespace bifrost {
    export class HighContrast {
      static getContrastConfig = (host: IVisualHost) : bifrost.HighContrastColors => {
        /*
          Typecasting is done to support older pbiversions
        */
        let colorPalette = <any>host.colorPalette;
        if (colorPalette.isHighContrast) {
          return {
            isHighContrast: true,
            foreground: colorPalette.foreground.value,
            background: colorPalette.background.value,
            foregroundSelected: colorPalette.foregroundSelected.value,
            hyperlink: colorPalette.hyperlink.value
          };
        } else {
          return {
            isHighContrast: false,
            foreground: null,
            background: null,
            foregroundSelected: null,
            hyperlink: null
          };
        }
      };
    }
  }
}

module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
  import IVisualHost = powerbi.extensibility.visual.IVisualHost;
  export namespace bifrost {
    export class DataViewSettingsUtils {

      static getColorPalatte(host: IVisualHost) {
        let colorPalette = host.colorPalette;
        // Not a suggested method, issue may occur in future
        if ((<any>extensibility).createColorPalette && (<any>colorPalette).colors) {
          colorPalette = (<any>extensibility).createColorPalette((<any>colorPalette).colors);
        }
        return colorPalette;
      }

      static getDataViewObjects({ dataView, measures, dimensions, host, mergePropsConfig, bifrostProperty }: { dataView: DataView, measures: Categorical.Measure[], dimensions: Categorical.Dimension[], host: IVisualHost, mergePropsConfig: any, bifrostProperty: any }): Categorical.Objects {
        const colorPalette = DataViewSettingsUtils.getColorPalatte(host);
        let measureObjects = measures
          .map((column, index) => {
            let columnSettings = DataViewSettingsUtils.getColumnSettings(dataView.categorical.values[index].source.objects)
            return {
              themeColor: colorPalette.getColor(column.id).value,
              name: column.name,
              id: column.id,
              settings: columnSettings
            }
          });
        let themeColors = DataViewSettingsUtils.getDimensionThemeColors(dimensions, colorPalette);
        let dimensionObjects = dimensions
          .map((column, index) => {
            let columnSettings = DataViewSettingsUtils.getColumnSettings(dataView.categorical.categories[index].source.objects)
            let mergeProp = mergePropsConfig.filter(mergeProp => mergeProp.dimensionId === column.id)[0];
            return {
              themeColor: themeColors[column.id],
              name: column.name,
              id: column.id,
              memberObjects: dataView.categorical.categories[index].objects || [],
              settings: columnSettings,
              mergedProps: mergeProp ? DataViewSettingsUtils.getGetMergedProps(dataView.categorical.categories[index], mergeProp, bifrostProperty) : null
            }
          });
        return {
          dimensions: dimensionObjects,
          measures: measureObjects
        } as Categorical.Objects;

      }
      static getDimensionThemeColors = (dimensions: Categorical.Dimension[], colorPalette: ISandboxExtendedColorPalette) => {
        if (dimensions.length === 0) {
          return {};
        }

        let rowLength = dimensions[0].values.length;
        let themeColors = {};
        for (let i = 0; i < rowLength; i++) {
          dimensions.forEach(dimension => {
            if (!themeColors[dimension.id]) {
              themeColors[dimension.id] = {};
            }
            var dimensionMember = dimension.values[i];
            if (!themeColors[dimension.id][dimensionMember] && dimensionMember) {
              themeColors[dimension.id][dimensionMember] = colorPalette.getColor(dimensionMember.toString()).value;
            }
          });
        }
        return themeColors;

      }
      static getGetMergedProps = (category: DataViewCategoryColumn, mergeProp, bifrostProperty) => {
        if (!category.objects) {
          category.objects = [];
        }

        let mergedProps = bifrostProperty.get("mergedProps") || {};
        let catMergedProps = mergedProps[mergeProp.dimensionId] || {};
        let visitedMembers = [];
        for (let rowIndex in category.values) {
          let member = category.values[rowIndex];
          let memberObjects = category.objects[rowIndex];
          if (!member || !memberObjects) {
            continue;
          }
          member = member.toString();
          if (visitedMembers.indexOf(member) !== -1){
            continue;
          }
       
          let memberMergedProp = catMergedProps[member] ? catMergedProps[member] : {};
          let updateProperty = false;
          let memberSettings = DataViewSettingsUtils.getColumnSettings(memberObjects);
          for (let property of mergeProp.properties) {
            let dimensionSection = property.dimensionSection || property.section;
            if (memberSettings[dimensionSection] && memberSettings[dimensionSection][property.name]) {
              memberMergedProp[property.section] = memberMergedProp[property.section] ? memberMergedProp[property.section] : {};
              memberMergedProp[property.section][property.name] = memberSettings[dimensionSection][property.name];
              updateProperty = true;
            }
          }
          if (updateProperty) {
            visitedMembers.push(member);
            catMergedProps[member] = memberMergedProp
          }
        }
        bifrostProperty.set("mergedProps", catMergedProps);
        return catMergedProps;
      }

      static getColumnSettings = (objects: DataViewObjects) => {
        let settings = {};
        if (!objects) return {};
        for (let sectionKey in objects) {
          let section = objects[sectionKey];
          settings[sectionKey] = {};
          for (let propertyKey in section) {
            if (section[propertyKey]["solid"]) {
              settings[sectionKey][propertyKey] = section[propertyKey]["solid"]["color"];
            } else {
              settings[sectionKey][propertyKey] = section[propertyKey];
            }
          }
        }
        return settings;
      }

      static mergeSettingsToOneCategory = () => {

      }
    }
  }
}

/**
 * @author Mano M
 */
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662.bifrost  {

    let PropertyType = bifrost.SettingsSchema.PropertyType;
    let IteratorType = bifrost.SettingsSchema.IteratorType;
    export class SettingsUISchemaBuilder {
        data: Data;
        selectionIdBuilder: SelectionIdBuilder;
        dataSource: DataView;
        host: IVisualHost;
        getBifrostProperty: Function;

        constructor(getBifrostProperty) {
            this.getBifrostProperty = getBifrostProperty;
        }

        isVisible = (settings: VisualSettings, property: any): boolean => {
            if (typeof property.isVisible === "function") {
                return property.isVisible(settings) === true;
            } else if (property.isVisible === false) {
                return false;
            } else {
                return true;
            }
        };

        setDataView(host: IVisualHost, dataSource: DataView, data: Data, selectionIdBuilder: SelectionIdBuilder) {
            this.data = data;
            this.dataSource = dataSource;
            this.selectionIdBuilder = selectionIdBuilder;
            this.host = host;
        }

        getPropertySchema = (sectionName, propertyName, propertyValue) => {
            return {
                objectName: sectionName,
                properties: {
                    [propertyName]: propertyValue
                },
                selector: null
            };
        }

        getPropertyValue(column: Categorical.Object, sectionName: string, propertyName: any, defaultValue: any): any {

            const settings = column.settings;
            if (settings[sectionName] && settings[sectionName][propertyName] !== undefined) {
                return settings[sectionName][propertyName];
            } else if (defaultValue) {
                return defaultValue;
            } else if (propertyName.indexOf("fill") !== -1 || propertyName.indexOf("color") !== -1) {
                return column.themeColor;
            }
            else if ((propertyName.indexOf("enable") !== -1 || propertyName.indexOf("show") !== -1)) {
                return false;
            }
            return null;
        }

        getSeriesName(metadata: Metadata, dataViewMeasure: Categorical.Measure) {
            let seriesName = DataObjectUtils.getMeasureLabelFromName(metadata, dataViewMeasure.name);
            if (dataViewMeasure.groupNames.length !== 0) {
                seriesName += ' - ';
                seriesName += dataViewMeasure.groupNames.join(" ");
            }
            return seriesName;
        }

        isRoleSelected(property: any, targetRole: any) {
            return property.roles.filter(role => targetRole.hasOwnProperty(role))[0];
        }

        getArrayPropertyConfig(property, settings) {
            let properties = [];
            property.name.forEach((propertyName, index) => {
                let defaultValue = null;
                let propertyConfig = this.getPropertyConfig({ ...property, defaultValue: false, name: propertyName }, settings)
                if (!propertyConfig) {
                    return;
                }
                if (property.defaultValue && Array.isArray(property.defaultValue)) {
                    if (property.defaultValue[index] && Array.isArray(property.defaultValue[index])) {
                        let propertyDefaultValue = property.defaultValue[index];
                        defaultValue = propertyDefaultValue[property.measureIndex % propertyDefaultValue.length];
                    }
                    else {
                        defaultValue = property.defaultValue[index];
                    }
                }
                properties.push({
                    name: propertyName,
                    displayName: propertyConfig.displayName,
                    value: defaultValue,
                });
            });
            return properties;
        }

        getPropertyConfig(property, settings) {
            if (typeof property.isIteratorVisible === "function") {
                if (!property.isIteratorVisible(settings, property.measureObject, property.name)) {
                    return false;
                }
            }
            if (property.defaultValue && Array.isArray(property.defaultValue)) {
                property.value = property.defaultValue[property.measureIndex % property.defaultValue.length];
            }

            if (typeof property.getIteratorText === "function") {
                property.displayName = property.getIteratorText(property.name, property.displayName)
            }
            return property;
        }
        getSchemaForSeries(settings: VisualSettings, property: any, sectionName: string, measuresOnly: boolean = false) {
            const objects = this.data.categorical.objects;
            const metadata = this.data.metadata;
            const measures: any[] = measuresOnly ? metadata.measures : this.data.categorical.measures;
            let properties = [];
            measures.forEach((dataViewMeasure, measureIndex) => {
                if (property.isVisible && typeof property.isVisible === "function") {
                    if (property.isVisible(settings, measureIndex) === false) {
                        return null;
                    }
                }
                if (!this.isRoleSelected(property, dataViewMeasure.role)) {
                    return null;
                }

                property.displayName = measuresOnly?  DataObjectUtils.getMeasureLabelFromName(metadata, dataViewMeasure.name) : this.getSeriesName(metadata, dataViewMeasure);
                property.measureIndex = measureIndex;
                property.measureObject = measuresOnly ?  DataObjectUtils.getMeasureObjects(
                    objects,
                    dataViewMeasure.name
                ) : DataObjectUtils.getMeasureObjectsFromId(
                    objects,
                    dataViewMeasure.id
                );
                if (Array.isArray(property.name)) {
                    let propertiesConfig = this.getArrayPropertyConfig(property, settings);
                    propertiesConfig.forEach(propertyConfig => {
                        properties.push({
                            objectName: sectionName,
                            displayName: propertyConfig.displayName,
                            properties: {
                                [propertyConfig.name]: this.getPropertyValue(property.measureObject, sectionName, propertyConfig.name, propertyConfig.value)
                            },
                            selector: this.selectionIdBuilder.getSelectionId({
                                seriesIndex: measuresOnly ? undefined :measureIndex,
                                measureName: dataViewMeasure.name
                            }).getSelector()
                        });
                    })
                }
                else {
                    let propertyConfig = this.getPropertyConfig(property, settings);
                    if (propertyConfig) {
                        properties.push({
                            objectName: sectionName,
                            displayName: propertyConfig.displayName,
                            properties: {
                                [property.name]: this.getPropertyValue(property.measureObject, sectionName, property.name, property.value)
                            },
                            selector: this.selectionIdBuilder.getSelectionId({
                                seriesIndex: measuresOnly ? undefined :measureIndex,
                                measureName: dataViewMeasure.name
                            }).getSelector()
                        });
                    }

                }
            });
            return properties;
        }

        getSchemaForGroup(property: any, sectionName: string) {
            if (!this.dataSource.categorical) return;
            let values = this.dataSource.categorical.values;
            let groupedData = values.grouped();
            let selectionIdBuilder = this.host.createSelectionIdBuilder();
            return groupedData.map(groupedCategory => {
                let selector = selectionIdBuilder.withSeries(values, groupedCategory).createSelectionId().getSelector();
                return {
                    objectName: sectionName,
                    displayName: groupedCategory.name,
                    properties: {
                        // The following line is hard coded once we got the bifrost implementation we can fix it.
                        [property.name]: "#FFF000"
                    },
                    selector
                };
            });

        }

        getMergedDimensionMembersSchema(property, sectionName, selectedDimension: Categorical.Dimension, categoricalIndexForSelectionID) {
            let rowLength = selectedDimension.values.length;
            let dimensionMemberSchemaList = [];
            let dimensionObjects = this.data.categorical.objects.dimensions;
            let dimensionObjectFromBifrostProp = this.getBifrostProperty("mergedProps") || {};
            dimensionObjectFromBifrostProp = dimensionObjectFromBifrostProp[selectedDimension.id] || {};
            let dimensionObject = dimensionObjects.filter(dimension => dimension.id === selectedDimension.id)[0];
            for (let memberIndex = 0; memberIndex < rowLength; memberIndex++) {
                var dimensionMember = selectedDimension.values[memberIndex];
                if (!dimensionMember) {
                    continue;
                }
                dimensionMember = dimensionMember.toString();
                var dimensionMemberSchemaIndex = -1;

                // Find Index
                for (let i = 0; i < dimensionMemberSchemaList.length; i++) {
                    if (dimensionMemberSchemaList[i].displayName === dimensionMember) {
                        dimensionMemberSchemaIndex = i;
                        break;
                    }
                }

                if (dimensionMemberSchemaIndex !== -1) {
                    var dimensionMemberSchema = dimensionMemberSchemaList[dimensionMemberSchemaIndex];
                    if (dimensionMemberSchema.properties[property.name] === null) {
                        let memberObject = dimensionObject.memberObjects[memberIndex];
                        dimensionMemberSchema.properties[property.name] = (memberObject && memberObject[sectionName]) ? memberObject[sectionName][property.name] : null;
                    }
                }
                else {
                    let memberObject = dimensionObjectFromBifrostProp[dimensionMember] ? dimensionObjectFromBifrostProp[dimensionMember] : null;
                    if (!memberObject) {
                        memberObject = dimensionObject.memberObjects ? dimensionObject.memberObjects[memberIndex] : null;
                    }
                    let value = (memberObject && memberObject[sectionName]) ? memberObject[sectionName][property.name] : null;
                    if ((value === null || value === undefined) && (property.name.indexOf("fill") !== -1 || property.name.indexOf("color") !== -1)) {
                        value = dimensionObject.themeColor[dimensionMember];
                    }
                    dimensionMemberSchemaList.push({
                        displayName: dimensionMember,
                        selector: this.selectionIdBuilder.getSelectionId({
                            categoricalIndex: categoricalIndexForSelectionID,
                            categoricalMemberIndex: memberIndex
                        }).getSelector(),
                        properties: {
                            [property.name]: value
                        }
                    })
                }
            }
            return dimensionMemberSchemaList;
        }

        getSchemaForCategory(property: any, sectionName: string) {

            let dimensions = this.data.categorical.dimensions;
            let selectedDimensions: Categorical.Dimension[] = [];
            let dimensionObjects = this.data.categorical.objects.dimensions;
            let categoricalIndexForSelectionID = -1;
            dimensions.forEach((dimension, dimensionIndex) => {
                if (this.isRoleSelected(property, dimension.role)) {
                    selectedDimensions.push(dimension);
                    categoricalIndexForSelectionID = dimensionIndex;
                }
            });
            if (typeof property.dimensionIndex === "number" && property.dimensionIndex < selectedDimensions.length && selectedDimensions.length > 1) {
                return this.getMergedDimensionMembersSchema(property, sectionName, selectedDimensions[property.dimensionIndex], property.dimensionIndex);
            }
            if (selectedDimensions.length > 0) {
                const rowLength = selectedDimensions[0].values.length;
                let dimensionMembersSchema = [];
                for (let memberIndex = 0; memberIndex < rowLength; memberIndex++) {
                    let dimensionMemberSchema = {
                        displayName: "",
                        selector: null,
                        properties: {
                            [property.name]: null
                        },
                        objectName: sectionName
                    };
                    for (let dimensionIndex = 0; dimensionIndex < selectedDimensions.length; dimensionIndex++) {
                        let dimensionMember = selectedDimensions[dimensionIndex].values[memberIndex];
                        let dimensionObject = dimensionObjects.filter(dimension => dimension.id === selectedDimensions[dimensionIndex].id)[0];
                        let memberObject = dimensionObject.memberObjects[memberIndex];
                        let value = (memberObject && memberObject[sectionName]) ? memberObject[sectionName][property.name] : null;
                        let propertyIndex = dimensionMembersSchema.length;
                        if ((value === null || value === undefined) && property.defaultValue) {
                            if (Array.isArray(property.defaultValue)) {
                                value = property.defaultValue[propertyIndex] === undefined ? null : property.defaultValue[propertyIndex];
                            }
                        }
                        if ((value === null || value === undefined) && (property.name.indexOf("fill") !== -1 || property.name.indexOf("color") !== -1)) {
                            value = dimensionObject.themeColor[dimensionMember];
                        }
                        dimensionMemberSchema.properties[property.name] = value;
                        if (dimensionMemberSchema.displayName === "") {
                            dimensionMemberSchema.displayName = dimensionMember;
                        } else {
                            dimensionMemberSchema.displayName += "/" + dimensionMember;
                        }
                    }
                    dimensionMemberSchema.selector = this.selectionIdBuilder.getSelectionId({
                        categoricalIndex: categoricalIndexForSelectionID,
                        categoricalMemberIndex: memberIndex
                    }).getSelector();
                    dimensionMembersSchema.push(dimensionMemberSchema);
                }
                return dimensionMembersSchema;
            } else {
                return [];
            }
        }

        generatePropertySchema(settings: VisualSettings, sectionName: string, property: any) {
            let iteratorObjects = [];
            if (property.iteratorType === IteratorType.SERIES) {
                iteratorObjects = this.getSchemaForSeries(settings, property, sectionName);
            } else if (property.iteratorType === IteratorType.MEASURE) {
                iteratorObjects = this.getSchemaForSeries(settings, property, sectionName,true);
            } else if (property.iteratorType === IteratorType.GROUP) {
                iteratorObjects = this.getSchemaForGroup(property, sectionName);
            } else if (property.iteratorType === IteratorType.DIMENSION) {
                iteratorObjects = this.getSchemaForCategory(property, sectionName);
            }
            return iteratorObjects.filter(iteratorObject => iteratorObject);
        };

        getPropertySchemaList(propertyConfig: any, settings: VisualSettings, sectionName: string, propertyName: string, propertyValue: string) {
            if (propertyConfig.type === PropertyType.ITERATOR && this.isVisible(settings, propertyConfig)) {
                return this.generatePropertySchema(settings, sectionName, propertyConfig);
            } else if (this.isVisible(settings, propertyConfig)) {
                return [this.getPropertySchema(sectionName, propertyName, propertyValue)];
            } else {
                return null;
            }
        }

        addValidValues(propertySchemaList: any[], configProperty: any) {
            if (!propertySchemaList)
                return [];

            return propertySchemaList.map(property => {
                if (configProperty.validValues) {
                    property.validValues = { [configProperty.name]: configProperty.validValues };
                }
                return property;
            });
        }

        getPropertiesSchema(properties: SettingsSchema.Property[], settings: VisualSettings, sectionName: string) {
            let enumerateObject: VisualObjectInstance[] = [];
            properties = this.updateIteratorProperties(properties);
            for (var propertyName in settings[sectionName]) {
                const configProperty = properties.filter(property => {
                    if (Array.isArray(property.name)) {
                        return property.name[0] === propertyName;
                    }
                    return property.name === propertyName
                })[0];
                const propertyValue = settings[sectionName][propertyName];
                if (configProperty) {
                    var propertySchemaList = this.getPropertySchemaList(configProperty, settings, sectionName, propertyName, propertyValue);
                    enumerateObject.push(...this.addValidValues(propertySchemaList, configProperty));
                } else {
                    enumerateObject.push(this.getPropertySchema(sectionName, propertyName, propertyValue));
                }
            }
            return enumerateObject;
        }

        getApplicableConfigurations(configurations, sectionName) {
            let iteratorConfig = null;
            configurations = configurations.filter((config, index) => {

                if (config.name === sectionName && !config.sectionIterator) {
                    return true;
                }
                let dimensionIndex = sectionName.replace(config.name, "");

                if (dimensionIndex.length === 1 && config.sectionIterator) {
                    let roleDimensions = this.data.categorical.dimensions.filter(dimension => {
                        return dimension.role[config.sectionIterator.role];
                    })
                    if (+dimensionIndex < roleDimensions.length) {
                        iteratorConfig = [{
                            name: sectionName,
                            isVisible: config.isVisible,
                            properties: [{
                                name: config.sectionIterator.property,
                                type: PropertyType.ITERATOR,
                                iteratorType: IteratorType.DIMENSION,
                                roles: [config.sectionIterator.role],
                                dimensionIndex: +dimensionIndex
                            }]
                        }]
                    }
                    else {
                        iteratorConfig = [{
                            name: sectionName,
                            isVisible: false
                        }];
                    }
                }
                return false
            });
            return iteratorConfig || configurations;
        }

        updateIteratorProperties(properties: SettingsSchema.Property[]) {
            let hideProperties = [];
            properties.forEach((property) => {
                if (Array.isArray(property.name)) {
                    hideProperties = hideProperties.concat(property.name.slice(1, property.name.length).map(propertyName => {
                        return {
                            name: propertyName,
                            isVisible: false
                        }
                    }));
                }
            });
            return properties.concat(hideProperties);
        }
        getEnumerateObjects(options: EnumerateVisualObjectInstancesOptions, settings: VisualSettings, configurations: SettingsSchema.Section[] = []) {
            const sectionName = options.objectName;

            configurations = this.getApplicableConfigurations(configurations, sectionName);
            if (configurations.length === 0) {
                return VisualSettings.enumerateObjectInstances(settings || VisualSettings.getDefault(), options);
            }
            let enumerateObject: VisualObjectInstance[] = [];
            configurations.forEach(configuration => {
                if (typeof configuration.isVisible === 'function' && configuration.isVisible(settings) === false) {
                    enumerateObject = [];
                } else if (configuration.isVisible === false) {
                    enumerateObject = [];
                } else {
                    enumerateObject = this.getPropertiesSchema(configuration.properties || [], settings, sectionName);
                }
            });
            return enumerateObject;
        };
    }
}

/**
  @author Mano M
*/
module powerbi.extensibility.visual.kpiTileVDTDAAAAECA2A9B4BB0920B352B6793C662  {
    export namespace bifrost {
        class ConditionalFormattingCore {
            private dataView: DataView;
            private bifrostData: bifrost.Data;
            private rules: IConditionalFormatting.Rule[] = [];
            private colors: string[] = [];
            private groupedItems: DataViewValueColumnGroup[];
            private valueColumn: DataViewValueColumn;
            private groupName: string;
            private decimalSeperator: string;

            constructor (dataView: DataView, bifrostData: bifrost.Data, rules: IConditionalFormatting.Rule[], valueColumn: DataViewValueColumn, decimalSeperator: string) {
                this.dataView = dataView;
                this.bifrostData = bifrostData;
                const categorical = dataView.categorical;

                if(categorical && categorical.values && categorical.values.source && 
                        typeof categorical.values.grouped === "function") {
                    this.groupedItems = categorical.values.grouped();
                    this.groupName = categorical.values.source.queryName;
                } else {
                    this.groupedItems = [];
                }
                if (rules && typeof rules === "string") {
                    this.rules = JSON.parse(rules);
                } else if (rules && typeof rules === "object") {
                    this.rules = rules;
                }
                this.valueColumn = valueColumn;
                this.colors = new Array(valueColumn.values.length);
                this.decimalSeperator = decimalSeperator;
            }

            private calculate(operator: string, value1: number, value2: number): number {
                switch (operator) {
                    case '+':
                        return value1 + value2;
                    case '-':
                        return value1 - value2;
                    case '*':
                        return value1 * value2;
                    case '/':
                        return value1 / value2;
                }
            }

            private compare(operator: string, value: number, compare: number, compare2?: number): boolean {
                const decimalParts = String(compare).split(this.decimalSeperator || ".")[1];
                let noOfDecimal = 2;
                if (decimalParts) {
                    noOfDecimal = decimalParts.length;
                }
                value = Number(Number(value).toFixed(noOfDecimal));
                compare = Number(Number(compare).toFixed(noOfDecimal));
                compare2 = Number(Number(compare2).toFixed(noOfDecimal));
                switch (operator) {
                    case ">":
                        return value > compare;
                    case ">=":
                        return value >= compare;
                    case "<":
                        return value < compare;
                    case "<=":
                        return value <= compare;
                    case "==":
                        return value === compare;
                    case "<>":
                        return value >= compare && value <= compare2;
                }
                return;
            }

            private getDistinctElement (inputArray) {
                if (Array.isArray(inputArray)) {
                    return inputArray.filter((item, pos) => inputArray.indexOf(item) === pos);
                }
                return []; 
            }

            public getColors = () => {
                this.applyRules();
                return this.colors;
            }

            private getMeasure(measureKey: string) {
                const values = this.dataView.categorical.values;
                const valueColumn = this.valueColumn.source;
                return values.filter(value => value.source.queryName === measureKey && valueColumn.groupName === value.source.groupName)[0];
            }



            private getDataFromSelection (selection: Categorical.Selection[]) {
                const selectionValue = DataSelection.getSelectionValue(this.bifrostData, selection);
                if (selectionValue && selectionValue[0] && selectionValue[0].measures && 
                    selectionValue[0].measures[0]) {
                    return selectionValue[0].measures[0].values[0];
                }
                return null;
            }

            private checkSingleMeasure = (rule: IConditionalFormatting.SingleMeasure, index: number): boolean => {
                let comparisionMeasure = this.getMeasure(rule.comparisionMeasure);
                if (comparisionMeasure && comparisionMeasure.values && comparisionMeasure.values[index]) {
                    const data = comparisionMeasure.values[index] as number;
                    if (rule.operator === "<>") {
                        if (rule.valueType === "static") {
                            if (this.compare(rule.operator, data, rule.from, rule.to)) {
                                return true;
                            }
                        } else {
                            const fromValue = this.getDataFromSelection(rule.dynamicFrom);
                            const toValue = this.getDataFromSelection(rule.dynamicTo);
                            if (this.compare(rule.operator, data, fromValue, toValue)) {
                                return true;
                            }
                        }
                    } else {
                        if (rule.valueType === "static") { 
                            if (this.compare(rule.operator, data, rule.comparisonValue)) {
                                return true;
                            }
                        } else {
                            const value = this.getDataFromSelection(rule.dynamicComparisonValue);
                            if (this.compare(rule.operator, data, value)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
                return false;
            }

            private checkMeasureCalculation = (rule: IConditionalFormatting.MeasureCalculation, index: number) => {
                let calculationMeasureData,
                    calculationMeasure1Data,
                    calculationMeasure2Data;

                const comparisionMeasure = this.getMeasure(rule.comparisionMeasure);
                if (comparisionMeasure && comparisionMeasure.values) {
                    calculationMeasureData = comparisionMeasure.values[index];
                }
                if (rule.calculationType1 === 'measure') {
                    let calculationMeasure1 = this.getMeasure(rule.calculationMeasure1);
                    if (calculationMeasure1 && calculationMeasure1.values) {
                        calculationMeasure1Data = calculationMeasure1.values[index] as number;
                    }
                } else {
                    calculationMeasure1Data = rule.calculationValue1;
                }

                if (rule.calculationType2 === 'measure') {
                    let calculationMeasure2 = this.getMeasure(rule.calculationMeasure2);
                    if (calculationMeasure2 && calculationMeasure2.values) {
                        calculationMeasure2Data = calculationMeasure2.values[index] as number;
                    }
                } else {
                    calculationMeasure2Data = rule.calculationValue2;
                }

                if (comparisionMeasure && calculationMeasure1Data && calculationMeasure2Data) {
                    const calculatedValue = this.calculate(rule.calculationOperator, calculationMeasure1Data , calculationMeasure2Data);
                    if (this.compare(rule.operator, calculationMeasureData, calculatedValue)) {
                        return true;
                    }
                }
                return false;
            }

            private checkDimension = (rule: IConditionalFormatting.Dimension, index: number) => {
                let categories = this.dataView.categorical.categories
                                .filter(category => category.source.queryName === rule.dimension)[0];
                if (rule.aggregationType === "includes") {
                    const dimensionMembers = rule.dimensionMembers.map(member => member.value);
                    if (categories && dimensionMembers.indexOf(<string>categories.values[index]) >= 0) {
                        return true;
                    }
                    else if (dimensionMembers.indexOf(<string>this.valueColumn.source.groupName) >= 0) {
                        return true;
                    }
                } else {
                    let  dimensionMembers,dimensionMembersCount;
                    if (categories && categories.values) {
                        dimensionMembers = categories.values;
                    } else if (this.groupedItems.length > 0 && this.groupName === rule.dimension) {
                        dimensionMembers = this.groupedItems;
                    }
                    if (dimensionMembers) {
                        if (rule.aggregationType === "count") {
                            dimensionMembersCount = dimensionMembers.length;
                        } else {
                            dimensionMembersCount = this.getDistinctElement(dimensionMembers).length;
                        }
                        if (this.compare(rule.countOperator, dimensionMembersCount, rule.count)) {
                            return true;
                        } else {
                            return false;
                        }
                    }
                } 
                return false;
            }

            private applyTargetRule = (colorRanges: IConditionalFormatting.TargetRule[], index: number, data: number) => {
                colorRanges.forEach(range => {
                    if (this.compare("<>", data, range.from, range.to)) {
                        this.colors[index] = range.color;
                    }
                });
            }

            private checkConditions = (rule: IConditionalFormatting.Rule) => {
                if (rule.enabled) {
                    this.valueColumn.values.forEach((data: number, index) => {
                        let conditionList = rule.conditions.map(condition => {
                            switch (condition.ruleType) {
                                case 'singleMeasure':
                                    return this.checkSingleMeasure(condition, index);
                                case 'measureCalculation':
                                    return this.checkMeasureCalculation(condition, index);
                                case 'dimension':
                                    return this.checkDimension(condition, index);
                                case 'targetValue':
                                    return this.applyTargetRule(condition.targetValue, index, data);
                            }
                        });
                        // The following line will be added in future when need conditions grouping
                        // const operators = rule.conditions.map(condition => condition.conditionalOperator);
                        const ruleSatisfied = conditionList.reduce((previous, current, index) => {
                            switch (rule.conditionalOperator) {
                                case 'or' : return (previous || current);
                                case 'and': return (previous && current);
                                case 'not': return (previous  && !current);
                            }
                        });
                        if (ruleSatisfied) {
                            this.colors[index] = rule.color;
                        }
                    });
                }
            }

            private applyRules() {
                this.rules.filter(rule => rule.highlighedMeasure === this.valueColumn.source.queryName).
                        forEach(this.checkConditions);
            }
        }

        export class ConditionalFormatting {
            private colors: string[][];
            constructor (dataView: DataView, bifrstData: bifrost.Data, rules: IConditionalFormatting.Rule[], decimalSeperator: string ) {
                const {values : measures} = dataView.categorical;
                this.colors = new Array<Array<string>>(Array.isArray(measures) ? measures.length : 0);
                if (measures) {
                    measures.map((measure, index) => {
                        this.colors[index] = new ConditionalFormattingCore(dataView, bifrstData, rules, measure, decimalSeperator).getColors();
                    });
               }
            }

            public getColors (index: number) {
                return this.colors[index] || [];
            }
        }
    }
}